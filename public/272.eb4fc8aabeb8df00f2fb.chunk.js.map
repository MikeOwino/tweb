{"version":3,"file":"272.eb4fc8aabeb8df00f2fb.chunk.js","mappings":"0HAWA,MAAMA,EAAuC,IAAIC,IACjD,IAAIC,EAAkB,EACtB,MAAMC,EAAY,CAACC,EAAsBC,EAAuBC,EAAiB,MAC/EA,EAASD,EAAKE,aAAeD,EAI7BJ,EAAkBM,KAAKC,IAAIP,EAAiBI,EAAOI,QACnDV,EAASW,IAAIL,EAAQ,CAACF,QAAAA,EAASC,KAAAA,KAG1B,SAASO,EAAkBC,GAMhCA,EAAcA,GAAe,GAEzBb,EAASc,MACX,iCAA2BV,IACzBA,EAAQW,cAAcC,SAAQX,IACzBA,EAAKL,SACNK,EAAKL,SAASgB,SAAQV,IACpBH,EAAUC,EAASC,EAAMC,MAG3BH,EAAUC,EAASC,SAO3B,IAYIY,EAZAC,EAAML,EAAYM,QAAQ,MAAO,IACjCC,EAAYF,EAAIG,MAAM,EAAGnB,GAY7B,IAAI,IAAIoB,EAAIF,EAAUV,OAAS,EAAGY,GAAK,IACrCL,EAAgBjB,EAASuB,IAAIH,EAAUC,MAAM,EAAGC,EAAI,KACjDL,KAFuCK,GAO5C,IAAIL,EACF,MAAO,CACLO,UAAWN,EACXd,aAASqB,EACTpB,UAAMoB,EACNC,YAAa,IAKjB,MAAMtB,EAAUa,EAAcb,QAExBuB,EAAWV,EAAcZ,KAAKsB,UAAY,GAC1CC,EAAmBV,EAAIG,MAAMJ,EAAcZ,KAAKE,aAAaG,QACnE,IAAImB,EAAU,GAAIC,EAA4B,EAAGC,EAAqB,GACtE,IAAI,IAAIT,EAAIK,EAASjB,OAAS,EAAGY,GAAK,IAAKA,EAAG,CAC5CO,EAAUF,EAASL,GAEnB,MAAMU,EAAWH,EAAQV,QAAQ,KAAM,IACvC,IAAIc,EAAiB,EACrB,IAAI,IAAIC,EAAI,EAAGxB,EAASF,KAAK2B,IAAIP,EAAiBlB,OAAQsB,EAAStB,QAASwB,EAAIxB,IAAUwB,EAAG,CAC3F,GAAGN,EAAiBM,KAAOF,EAASE,IAAsB,MAAhBF,EAASE,GAE5C,CACLD,EAAiB,EACjB,QAHEA,EAOHA,EAAiBH,IAClBA,EAA4BG,EAC5BF,EAAqBF,GAIzBA,EAAUE,GAAsBF,EAChCA,EAAUA,EAAQV,QAAQ,MAAO,KAEjCU,EAAUZ,EAAcZ,KAAKE,aAAe,IAAMsB,EAElDA,EAAQO,MAAM,IAAIpB,SAAQ,CAACqB,EAAQC,KACnB,MAAXD,GAA+B,MAAbnB,EAAIoB,IAAgBpB,EAAIR,OAAS4B,IACpDpB,EAAMA,EAAIG,MAAM,EAAGiB,GAAO,IAAMpB,EAAIG,MAAMiB,OAQ9C,IAAIZ,EAAcG,GAAWA,EAAQnB,OAASQ,EAAIR,OAASmB,EAAQR,MAAMH,EAAIR,QAAU,GAQvF,OAPGgB,IAGDA,EAAcA,EAAYP,QAAQ,KAAM,MAInC,CAACK,UAAWN,EAAKd,QAAAA,EAASC,KAAMY,EAAcZ,KAAMqB,YAAAA","sources":["webpack://tweb/./src/helpers/formatPhoneNumber.ts"],"sourcesContent":["/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport { HelpCountry, HelpCountryCode } from \"../layer\";\nimport I18n from \"../lib/langPack\";\n\nlet sortedCountries: HelpCountry[];\ntype PrefixCountry = {country: HelpCountry, code: HelpCountryCode};\nconst prefixes: Map<string, PrefixCountry> = new Map();\nlet maxPrefixLength = 0;\nconst setPrefix = (country: HelpCountry, code: HelpCountryCode, prefix: string = '') => {\n  prefix = code.country_code + prefix;\n  /* if(prefixes.has(prefix)) {\n    console.error('asdasdasd', prefixes.get(prefix), country, code);\n  } */\n  maxPrefixLength = Math.max(maxPrefixLength, prefix.length);\n  prefixes.set(prefix, {country, code});\n};\n\nexport function formatPhoneNumber(originalStr: string): {\n  formatted: string,\n  country: HelpCountry,\n  code: HelpCountryCode,\n  leftPattern: string\n} {\n  originalStr = originalStr || '';\n  \n  if(!prefixes.size) {\n    I18n.countriesList.forEach(country => {\n      country.country_codes.forEach(code => {\n        if(code.prefixes) {\n          code.prefixes.forEach(prefix => {\n            setPrefix(country, code, prefix);\n          });\n        } else {\n          setPrefix(country, code);\n        }\n      });\n    });\n  }\n\n  // return {formatted: originalStr, country: undefined as any, leftPattern: ''};\n  let str = originalStr.replace(/\\D/g, '');\n  let phoneCode = str.slice(0, maxPrefixLength);\n  \n  ////console.log('str', str, phoneCode);\n  // if(!sortedCountries) {\n  //   sortedCountries = I18n.countriesList.slice().sort((a, b) => b.country_codes[0].country_code.length - a.country_codes[0].country_code.length);\n  // }\n  \n  // let country = sortedCountries.find((c) => {\n  //   return c.country_codes.find((c) => phoneCode.indexOf(c.replace(/\\D/g, '')) === 0);\n  // });\n\n  let prefixCountry: PrefixCountry;\n  for(let i = phoneCode.length - 1; i >= 0; --i) { // lookup for country by prefix\n    prefixCountry = prefixes.get(phoneCode.slice(0, i + 1));\n    if(prefixCountry) {\n      break;\n    }\n  }\n\n  if(!prefixCountry) {\n    return {\n      formatted: str, \n      country: undefined, \n      code: undefined, \n      leftPattern: ''\n    };\n  }\n\n  // country = /* PhoneCodesMain[country.phoneCode] ||  */country;\n  const country = prefixCountry.country;\n  \n  const patterns = prefixCountry.code.patterns || [];\n  const searchForPattern = str.slice(prefixCountry.code.country_code.length); // splice country code\n  let pattern = '', mostMatchedPatternMatches = 0, mostMatchedPattern = '';\n  for(let i = patterns.length - 1; i >= 0; --i) {\n    pattern = patterns[i];\n\n    const _pattern = pattern.replace(/ /g, '');\n    let patternMatches = 0;\n    for(let k = 0, length = Math.min(searchForPattern.length, _pattern.length); k < length; ++k) {\n      if(searchForPattern[k] === _pattern[k] || _pattern[k] === 'X') {\n        ++patternMatches;\n      } else {\n        patternMatches = 0;\n        break;\n      }\n    }\n\n    if(patternMatches > mostMatchedPatternMatches) {\n      mostMatchedPatternMatches = patternMatches;\n      mostMatchedPattern = pattern;\n    }\n  }\n\n  pattern = mostMatchedPattern || pattern;\n  pattern = pattern.replace(/\\d/g, 'X');\n\n  pattern = prefixCountry.code.country_code + ' ' + pattern;\n  // let pattern = country.pattern || country.phoneCode;\n  pattern.split('').forEach((symbol, idx) => {\n    if(symbol === ' ' && str[idx] !== ' ' && str.length > idx) {\n      str = str.slice(0, idx) + ' ' + str.slice(idx);\n    }\n  });\n  \n  /* if(country.pattern) {\n    str = str.slice(0, country.pattern.length);\n  } */\n\n  let leftPattern = pattern && pattern.length > str.length ? pattern.slice(str.length) : '';\n  if(leftPattern) {\n    /* const length = str.length;\n    leftPattern = leftPattern.split('').map((_, idx) => (length + idx).toString().slice(-1)).join(''); */\n    leftPattern = leftPattern.replace(/X/g, 'â€’');\n    // leftPattern = leftPattern.replace(/X/g, '0');\n  }\n  \n  return {formatted: str, country, code: prefixCountry.code, leftPattern};\n}\n"],"names":["prefixes","Map","maxPrefixLength","setPrefix","country","code","prefix","country_code","Math","max","length","set","formatPhoneNumber","originalStr","size","country_codes","forEach","prefixCountry","str","replace","phoneCode","slice","i","get","formatted","undefined","leftPattern","patterns","searchForPattern","pattern","mostMatchedPatternMatches","mostMatchedPattern","_pattern","patternMatches","k","min","split","symbol","idx"],"sourceRoot":""}